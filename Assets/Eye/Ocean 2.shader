Shader "Anthony/Experimental/Ocean 2"
{
    Properties
    {
        [Header(Water)] [Space]
        _MainTex ("Texture", 2D) = "white" {}
        _Color ("Color", Color) = (1,1,1,1)
        _Alpha ("Alpha", Range(0, 1)) = 0.9
        _Glossiness ("Smoothness", Range(0,1)) = 0.0
        _Metallic ("Metallic", Range(0,1)) = 0.0

        [Header(Specular)] [Space]
        _SpecularColor ("Specular Color", Color) = (1,1,1,1)
        _SpecularPower("Specular Power", Float) = 1
        _SpecularFalloff("Specular Fall Off", Range(0, 0.5)) = 0.2
        _Perturbation ("Perturbation", Range(0, 1)) = 0.5
        _SunIntensity ("Sun Intensity", Float) = 1

        [Header(Normal)]
        _BumpTex("Normal Map", 2D) = "bump" {}
        _BumpStrength("Bump Strength", Float) = 1

        _FlowTilingScale1("Flow Tiling 1 (XY) Scale (ZW)", Vector) = (1, 1, 1, 1)
        _FlowSpeed1("Flow Speed 1 (XY)", Vector) = (1, 1, 0, 0)
        _FlowTilingScale2("Flow Tiling 2 (XY) Scale (ZW)", Vector) = (1, 1, 1, 1)
        _FlowSpeed2("Flow Speed 2 (XY)", Vector) = (0, 0.5, 0, 0)

        _DepthThreshold ("Depth Threshold", Float) = 1
        [HDR] _IntersectColor ("Intersect Color", Color) = (1,1,1,1)

        // What color the water will sample when the surface below is shallow.
        _DepthGradientShallow("Depth Gradient Shallow", Color) = (0.325, 0.807, 0.971, 0.725)

        // What color the water will sample when the surface below is at its deepest.
        _DepthGradientDeep("Depth Gradient Deep", Color) = (0.086, 0.407, 1, 0.749)

        // Maximum distance the surface below the water will affect the color gradient.
        _DepthMaxDistance("Depth Maximum Distance", Float) = 1

        // Color to render the foam generated by objects intersecting the surface.
        _FoamColor("Foam Color", Color) = (1,1,1,1)

        // Control the distance that surfaces below the water will contribute
        // to foam being rendered.
        _FoamMaxDistance("Foam Maximum Distance", Float) = 0.4
        _FoamMinDistance("Foam Minimum Distance", Float) = 0.04

        [Header(DistanceColor)]
        [Space]
        _DistanceRange("Distance Range", Float) = 30
        _CloseColor ("Close Color", Color) = (0, 0, 0, 1)
        _FarColor ("Far Color", Color) = (1,1,1,1)

        [Header(Underwater)]
        _DeepColor("Underwater Deep", Color) = (0, 1, 0)
        _ShallowColor("Underwater Shallow", Color) = (0, 0, 1)
        _FogDensity("Fog Density", Float) = 0.1
        _FogScale("Fog Scale", Float) = 0
        _SSSOpacity("SSS Opacity", Range(0, 2)) = 1

        [Header(Reflections)]
        _Reflectivity ("Reflectivity", Range(0, 1.0)) = 0.5
        _ReflectionNormalStrength ("Reflection Normal Strength", Range(0, 1)) = 1

        [Header(Circle)]
        _CircleFalloff ("Circle Falloff", Range(0, 1)) = 0.8
        _CircleFalloffSmoothness ("Circle Falloff Smoothness", Range(0, 1)) = 0.1

        [Header(Waves)]
        [Toggle(GESTNER)] _UseGestnerWaves ("Use Waves?", Float) = 1
        _WaveA("Wave A (dir, steepness, wavelength)", Vector) = (1,0,0.5,10)
        _WaveB("Wave B", Vector) = (0,1,0.25,20)

        [Header(Underwater)]
        _SubmergeTex ("Submerge Texture", 2D) = "black" {}

        [Header(FoamPeaks)] [Space]
        _FoamPeakTex ("Foam Peak Tex", 2D) = "white" {}
        _FoamPeaksSpeed ("Foam Peak Speed", Float) = 0.2
        _FoamPeaksOpacity ("Foam Peak Opacity", Range(0, 1)) = 0.8
        _FoamMask("Foam Mask", Range(0, 1)) = 1
        _FoamHeightMultiplier ("Foam Height Multiplier", Float) = 0.5
        _FoamWaveMaskExp("Foam Exponent", Range(1, 8)) = 2.2
        
        [Header(Stencil)][Space]
        _Stencil ("Stencil", Float) = 2

    }
    CGINCLUDE

    #include "RGBShadersShared.cginc"
    #include "RGBLighting.cginc"

    #define SMOOTHSTEP_AA 0.01


    // Blends two colors using the same algorithm that our shader is using
            // to blend with the screen. This is usually called "normal blending",
            // and is similar to how software like Photoshop blends two layers.
    float4 alphaBlend(float4 top, float4 bottom)
    {
        float3 color = (top.rgb * top.a) + (bottom.rgb * (1 - top.a));
        float alpha = top.a + bottom.a * (1 - top.a);

        return float4(color, alpha);
    }

    struct Input
    {
        float2 uv_MainTex;
        float3 worldNormal;
        INTERNAL_DATA
        float3 worldPos;
        float4 screenPos;
        float3 viewDir;
        float3 viewNormal;
        float facing : VFACE;
        float3 nearPlanePos;
    };

    sampler2D _MainTex;
    half _Glossiness;
    half _Metallic;
    fixed4 _Color;
    float _Alpha;

    float _SpecularFalloff;

    float4 _FlowTilingScale1;
    float4 _FlowSpeed1;
    float4 _FlowTilingScale2;
    float4 _FlowSpeed2;

    uniform sampler2D _CameraDepthTexture;
    sampler2D _CameraNormalsTexture;

    float _DepthThreshold;
    float4 _IntersectColor;

    float _DepthMaxDistance;
    float4 _DepthGradientShallow;
    float4 _DepthGradientDeep;

    float _FoamMaxDistance;
    float _FoamMinDistance;

    float _Reflectivity;
    float _ReflectionNormalStrength;
    uniform sampler2D _PlanarReflectionRT;

    float _CircleFalloff;
    float _CircleFalloffSmoothness;

    // Waves
    float4 _WaveA;
    float4 _WaveB;

    // Submergence
    uniform float WaterLevel;
    sampler2D _SubmergeTex;

    ENDCG
    SubShader
    {
        Stencil
        {
            Ref [_Stencil]
            Comp NotEqual
            Pass Keep
            Fail Keep
            ZFail Keep
        }
        
        Tags 
        { 
            "RenderType" = "Transparent"
            "IgnoreProjector" = "True"
            "Queue" = "Transparent"
        }
        LOD 200

        Blend SrcAlpha OneMinusSrcAlpha // additive blending for a simple "glow" effect
        Cull Off // render backfaces as well
        ZWrite On // don't write into the Z-buffer, this effect shouldn't block objects
        ZTest LEqual

        CGPROGRAM
        #pragma surface surf Ocean fullforwardshadows vertex:vert 
        #pragma target 4.5
        #pragma shader_feature GESTNER

        //Current camera
        #define NEAR_PLANE _ProjectionParams.y
        #define ASPECT _ScreenParams.x / _ScreenParams.y
        #define CAM_FOV unity_CameraInvProjection._m11
        #define CAM_POS _WorldSpaceCameraPos
        #define CAM_RIGHT unity_WorldToCamera[0].xyz //Possibly flipped as well, but doesn't matter
        #define CAM_UP unity_WorldToCamera[1].xyz
        //The array variant is flipped when stereo rendering is in use. Using the camera center forward vector also works for VR
        #define CAM_FWD -UNITY_MATRIX_V[2].xyz

        float3 GerstnerWave(
            float4 wave, float3 p, inout float3 tangent, inout float3 binormal
        ) {
            float steepness = wave.z;
            float wavelength = wave.w;
            float k = 2 * UNITY_PI / wavelength;
            float c = sqrt(9.8 / k);
            float s = max(abs(wave.x), abs(wave.y));
            float2 d = normalize(wave.xy);
            float f = k * (dot(d, p.xz) - c * _Time.y * s);
            float a = steepness / k;

            //p.x += d.x * (a * cos(f));
            //p.y = a * sin(f);
            //p.z += d.y * (a * cos(f));

            tangent += float3(
                -d.x * d.x * (steepness * sin(f)),
                d.x * (steepness * cos(f)),
                -d.x * d.y * (steepness * sin(f))
            );
            binormal += float3(
                -d.x * d.y * (steepness * sin(f)),
                d.y * (steepness * cos(f)),
                -d.y * d.y * (steepness * sin(f))
            );
            return float3(
                d.x * (a * cos(f)),
                a * sin(f),
                d.y * (a * cos(f))
            );
        }

        void vert(inout appdata_full v, out Input o)
        {
            UNITY_INITIALIZE_OUTPUT(Input, o);
            o.viewNormal = COMPUTE_VIEW_NORMAL;

            //v.vertex.xyz = mul(unity_ObjectToWorld, v.vertex.xyz);

            // Gestner Waves
            #ifdef GESTNER
            float3 gridPoint = mul(unity_ObjectToWorld, v.vertex.xyz);
            float3 tangent = float3(1, 0, 0);
            float3 binormal = float3(0, 0, 1);
            float3 p = v.vertex.xyz;
            p += GerstnerWave(_WaveA, gridPoint, tangent, binormal);
            p += GerstnerWave(_WaveB, gridPoint, tangent, binormal);
            float3 normal = normalize(cross(binormal, tangent));

            v.normal = normal;
            v.vertex.xyz = p;
            #endif


            // World Curvature
            /*float3 worldToCam = o.worldPos - _WorldSpaceCameraPos.xyz;
            float YOffset = pow(worldToCam.z, 2) * -_WorldCurvature;
            float3 vertexOffset = float3(0, YOffset, 0);
            float3 position = o.worldPos + vertexOffset;
            position = mul(unity_WorldToObject, position);*/

            //// Transform the vertex coordinates from model space into world space
            //float4 vv = mul(unity_ObjectToWorld, v.vertex);

            //// Now adjust the coordinates to be relative to the camera position
            //vv.xyz -= _WorldSpaceCameraPos.xyz;

            //// Reduce the y coordinate (i.e. lower the "height") of each vertex based
            //// on the square of the distance from the camera in the z axis, multiplied
            //// by the chosen curvature factor
            //vv = float4(0.0f, (vv.z * vv.z) * -_WorldCurvature, 0.0f, 0.0f);

            //// Now apply the offset back to the vertices in model space
            //v.vertex += mul(unity_WorldToObject, vv);

            float4 vertexProgjPos = mul(UNITY_MATRIX_MV, v.vertex);
            o.nearPlanePos = v.vertex;
            //v.color.a *= saturate((-vertexProgjPos.z - _ProjectionParams.y) / (_CamFade + 0.001));
        }

        float isUnderwater = 0;
        float _DistanceRange;
        float4 _CloseColor;
        float4 _FarColor;

        sampler2D _FoamPeakTex;
        float4 _FoamPeakTex_ST;
        float _FoamPeaksSpeed;
        float _FoamPeaksOpacity;

        float _FoamMask;
        float _FoamHeightMultiplier;
        float _FoamWaveMaskExp;

        float foamPeakness;

        void surf (Input i, inout SurfaceOutputStandardSpecular o)
        {
            /////////////////////////////////////////////
            // Standard + Alpha
            o.Specular = _SpecularColor;
            o.Smoothness = _Glossiness;
            o.Alpha = _Alpha;

            /////////////////////////////////////////
            // Normal Calculations
            fixed2 flowUV1;
            flowUV1.x = (i.worldPos.x + _Time.x * _FlowSpeed1.x) * 
                _FlowTilingScale1.zw / _FlowTilingScale1.xy;
            flowUV1.y = (i.worldPos.z + _Time.x * _FlowSpeed1.y) * 
                _FlowTilingScale1.zw / _FlowTilingScale1.xy;

            fixed2 flowUV2;
            flowUV2.x = (i.worldPos.x + _Time.x * _FlowSpeed2.x) * 
                _FlowTilingScale2.zw / _FlowTilingScale2.xy;
            flowUV2.y = (i.worldPos.z + _Time.x * _FlowSpeed2.y) * 
                _FlowTilingScale2.zw / _FlowTilingScale2.xy;

            fixed3 N1 = UnpackScaleNormal(tex2D(_BumpTex, flowUV1 ), _BumpStrength);
            fixed3 N2 = UnpackScaleNormal(tex2D(_BumpTex, flowUV2 ), _BumpStrength);

            fixed3 N = lerp(N1, N2, 0.5);

            o.Normal = N;

            ////////////////////////////////////////////////////////////
            // Depth rendering and Foam
            // Retrieve the current depth value of the surface behind the
            // pixel we are currently rendering.
            // raw depth
            float existingDepth01 = tex2Dproj(_CameraDepthTexture, UNITY_PROJ_COORD(i.screenPos)).r;
            // Convert the depth from non-linear 0...1 range to linear
            // depth, in Unity units.
            float existingDepthLinear = LinearEyeDepth(existingDepth01);

            // Difference, in Unity units, between the water's surface and the object behind it.
            float depthDifference = existingDepthLinear - i.screenPos.w;

            // Calculate the color of the water based on the depth using our two gradient colors.
            float waterDepthDifference01 = saturate(depthDifference / _DepthMaxDistance);
            float4 waterColor = lerp(_DepthGradientShallow, _DepthGradientDeep, waterDepthDifference01);

            // Retrieve the view-space normal of the surface behind the
            // pixel we are currently rendering.
            float3 existingNormal = tex2Dproj(_CameraNormalsTexture, UNITY_PROJ_COORD(i.screenPos));

            float3 normalDot = saturate(dot(existingNormal, i.viewNormal));
            float foamDistance = lerp(_FoamMaxDistance, _FoamMinDistance, normalDot);
            float foamDepthDifference01 = saturate(depthDifference / foamDistance);

            float foamDiff = foamDepthDifference01; // *(1.0 - ripples.b);
            float4 waterTopColor = (1 - foamDiff) * _IntersectColor;

            o.Albedo = alphaBlend(waterTopColor, waterColor);


            ///////////////////////////////////////////////////////////
            // Underwater surface
            float3 viewDir = _WorldSpaceCameraPos - i.worldPos;
            float viewDist = length(viewDir);
            viewDir = viewDir / viewDist;

            float submergence = tex2D(_SubmergeTex, i.screenPos.xy / i.screenPos.w);

            bool backface = dot(i.worldNormal, viewDir) < 0;
            bool underwater = i.facing < 0 || submergence < 0.5;

            if (!underwater && backface) 
            {
                // Reflect normal vector so light renders differently
                o.Normal = reflect(o.Normal, i.viewDir);
            }
            // front face but underwater
            else if (underwater && !backface) 
            {
                o.Normal = reflect(o.Normal, i.viewDir);
            }

            // Color underwater
            if (underwater) 
            {
                //o.Albedo = float3(1, 0, 0);
                float distAlpha = viewDist / _DistanceRange;
                o.Albedo = lerp(_CloseColor, _FarColor, distAlpha);

                isUnderwater = 1;
            }
            else 
            {
                isUnderwater = 0;
            }

            // Backface
            if (backface) 
            {
                o.Normal = reflect(o.Normal, i.viewDir);
            }
            // Reflection color (for surface only)
            if (i.facing > 0)
            {
                /////////////////////////////////////////////////////
                // Reflections
                fixed2 screenUV = i.screenPos.xy / i.screenPos.w;
                screenUV.x = 1 - screenUV.x;

                fixed2 waterUV = screenUV.xy + N * _ReflectionNormalStrength;
                waterUV = saturate(waterUV);

                fixed4 reflectionColor = tex2D(_PlanarReflectionRT, waterUV);
                o.Albedo = lerp(o.Albedo, reflectionColor.rgb, _Reflectivity);

                // Foam peaks
                float CurrentHeight = i.worldPos.y;

                // Foam peak sample
                float2 foamPeakUvs1 = i.worldPos.xz * _FoamPeakTex_ST.xy + _FoamPeakTex_ST.zw;
                float2 foamPeakUvs2 = i.worldPos.xz * _FoamPeakTex_ST.xy * 1.5 + _FoamPeakTex_ST.zw;

                float foamPeakSample1 = tex2D(_FoamPeakTex, foamPeakUvs1 + float2(-0.2, -0.4) * _FoamPeaksSpeed * _Time.y).r;
                float foamPeakSample2 = tex2D(_FoamPeakTex, foamPeakUvs2 + float2(0.4, 0.25) * _FoamPeaksSpeed * _Time.y * 0.8).r;

                float foamPeakSample = max(foamPeakSample1, foamPeakSample2);
                float waterOffset = saturate((CurrentHeight - WaterLevel) * _FoamHeightMultiplier);
                float foamMask = lerp(1, waterOffset, _FoamMask);
                foamMask = pow(abs(foamMask), _FoamWaveMaskExp);
                foamPeakness = foamMask * foamPeakSample * _FoamPeaksOpacity;
                    //(1 - foamAlpha) * foamPeakSample * foamPeakMask * _FoamPeaksOpacity;
                //foamPeakColor = lerp(o.Albedo, 1, (1 - foamAlpha) * foamPeakSample * foamPeakMask * _FoamPeaksOpacity);
            }

            //s = lerp(o.Albedo, reflectionColor.rgb, _Reflectivity);

            //// Sample depth
            //float depth = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.screenPos);
            //depth = Linear01Depth(depth) * _ProjectionParams.z;
            //// Get normalized ray from the camera
            //float3 worldRay = normalize(i.worldPos - _WorldSpaceCameraPos);
            //worldRay /= dot((worldRay), -UNITY_MATRIX_V[2].xyz);
            //float3 worldPos = _WorldSpaceCameraPos + worldRay * depth;

            //o.Albedo = (worldPos);

            //if (i.facing < 0) {
            //    // Clip plane pos
            //    o.Albedo = 1 - length(mul(unity_CameraInvProjection, float4(1, 1, 0, 1)).xyz);
            //        //saturate((-i.nearPlanePos.z - _ProjectionParams.y));
            //    //i.nearPlanePos;
            ////v.color.a *= saturate((-vertexProgjPos.z - _ProjectionParams.y) / (_CamFade + 0.001));
            //}
            //
            //o.Albedo =  length(mul(unity_CameraInvProjection, float4(1, 1, 0, 1)).xyz);

            //o.Albedo = i.facing < 0 ? float3(1, 0, 0) : 1;
        }

        float _Perturbation;
        float _SunIntensity;

        float ShlickFresnel(float3 viewDir, float3 normal)
        {
            const float R = 0.02;
            return R + (1 - R) * Pow5(1 - saturate(abs(dot(viewDir, normal))));
        }

        float3 _DeepColor, _ShallowColor;
        float _FogScale, _SSSOpacity, _FogDensity;

        float3 UnderwaterFogColor(float3 viewDir, float3 lightDir, float depth)
        {
            float depthScale = _FogScale;
            // subsurface scattering
            float bias = min(0, depth * 0.02);
            float sssFactor = 0.1 * pow(max(0, 1 - viewDir.y + bias), 3);
            sssFactor *= 1 + pow(saturate(dot(lightDir, -viewDir)), 4);
            sssFactor *= saturate(1 - depthScale);
            float3 color = _DeepColor * max(0.5, saturate(2 - viewDir.y + bias));
            float3 sssColor = _ShallowColor;
            color = color + sssColor * sssFactor * _SSSOpacity;

            return color;
        }

        float3 ColorThroughWater(float3 color, float3 volumeColor, float distThroughWater, float depth)
        {
            distThroughWater = max(0, distThroughWater);
            depth = max(0, depth);
            //color *= AbsorptionTint(exp(-(distThroughWater + depth) / Ocean_AbsorptionDepthScale));
            return lerp(color, volumeColor, 1 - saturate(exp(-_FogDensity * distThroughWater)));
        }

        // Lighting
        inline fixed4 LightingOcean(SurfaceOutputStandardSpecular s, fixed3 viewDir, UnityGI gi)
        {
            //return foamPeakness;

            // Fresnel
            //float3 fresnel = Fresnel(N, V);

            float3 L = gi.light.dir;
            float3 V = viewDir;
            float3 N = s.Normal;

             // Specular
            float3 offset = N * _Perturbation;

            float3 R = reflect(normalize(L), N);
            float3 VdotR = dot(normalize(V + offset), -R);
            float3 specular =
                smoothstep(1 - s.Smoothness - _SpecularFalloff * 0.5, 1 - s.Smoothness + _SpecularFalloff * 0.5, VdotR);
            specular = pow(specular, _SpecularPower);
            specular *= _LightColor0;
            
            // Above water: Specular lighting
            if (isUnderwater == 0) 
            {
                // PBR
                fixed4 pbr = LightingStandardSpecular(s, viewDir, gi);

                pbr.rgb = lerp(pbr.rgb, 1, foamPeakness);

                pbr.rgb += specular * _SunIntensity;

                pbr *= s.Alpha;
                return pbr;
            }
            // Underwater: Fresnel Fog lighting
            else 
            {
                const float n = 1.1;
                float3 refractionDir = refract(-V, -N, n);

                float fresnel = max(ShlickFresnel(V, N), dot(refractionDir, refractionDir) < 0.5);

                float3 refraction;
                float4 probeRefract = UNITY_SAMPLE_TEXCUBE(unity_SpecCube0, refractionDir);
                refraction = DecodeHDR(probeRefract, unity_SpecCube0_HDR);

                float3 reflection;
                float3 reflNormal = N;
                reflNormal.xz *= 0.2;
                reflNormal = normalize(reflNormal);
                float3 backReflDir = reflect(V, reflNormal);
                reflection = UnderwaterFogColor(backReflDir, _WorldSpaceLightPos0.xyz, 0);
                
                float3 col = lerp(refraction, reflection, fresnel);
                float3 volume = UnderwaterFogColor(V, _WorldSpaceLightPos0.xyz, _WorldSpaceCameraPos.y);
                col = ColorThroughWater(col, volume, length(V) - _ProjectionParams.y, 0);
                //col += specular * _SunIntensity * 0.1;

                //float3 col = s.Albedo + specular * _SunIntensity;
                return float4(col, s.Alpha);
            }
        }

        void LightingOcean_GI(SurfaceOutputStandardSpecular s, UnityGIInput data, inout UnityGI gi) {
            Unity_GlossyEnvironmentData g = 
                UnityGlossyEnvironmentSetup(s.Smoothness, data.worldViewDir, s.Normal, s.Specular);
            gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
        }
        ENDCG
    }
    FallBack "Transparent/VertexLit"
}

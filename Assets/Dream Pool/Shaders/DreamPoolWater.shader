Shader "Anthony/Dream Pool Water"
{
    Properties
    {
        [Header(Water)] [Space]
        _MainTex ("Texture", 2D) = "white" {}
        _Color ("Color", Color) = (1,1,1,1)
        _Alpha ("Alpha", Range(0, 1)) = 0.9
        _Glossiness ("Smoothness", Range(0,1)) = 0.0
        _Metallic ("Metallic", Range(0,1)) = 0.0
        _SpecularColor ("Specular", Color) = (1,1,1,1)

        [Header(Light)] [Space]
        _SunIntensity ("Sun Intensity", Float) = 1

        [Header(Normal)]
        _BumpTex("Normal Map", 2D) = "bump" {}
        _BumpStrength("Bump Strength", Float) = 1

        _FlowTilingScale1("Flow Tiling 1 (XY) Scale (ZW)", Vector) = (1, 1, 1, 1)
        _FlowSpeed1("Flow Speed 1 (XY)", Vector) = (1, 1, 0, 0)
        _FlowTilingScale2("Flow Tiling 2 (XY) Scale (ZW)", Vector) = (1, 1, 1, 1)
        _FlowSpeed2("Flow Speed 2 (XY)", Vector) = (0, 0.5, 0, 0)

        _DepthThreshold ("Depth Threshold", Float) = 1
        [HDR] _IntersectColor ("Intersect Color", Color) = (1,1,1,1)

        // What color the water will sample when the surface below is shallow.
        _DepthGradientShallow("Depth Gradient Shallow", Color) = (0.325, 0.807, 0.971, 0.725)

        // What color the water will sample when the surface below is at its deepest.
        _DepthGradientDeep("Depth Gradient Deep", Color) = (0.086, 0.407, 1, 0.749)

        // Maximum distance the surface below the water will affect the color gradient.
        _DepthMaxDistance("Depth Maximum Distance", Float) = 1

        // Color to render the foam generated by objects intersecting the surface.
        _FoamColor("Foam Color", Color) = (1,1,1,1)

        // Control the distance that surfaces below the water will contribute
        // to foam being rendered.
        _FoamMaxDistance("Foam Maximum Distance", Float) = 0.4
        _FoamMinDistance("Foam Minimum Distance", Float) = 0.04

        [Header(Waves)]
        [Toggle(GESTNER)] _UseGestnerWaves ("Use Waves?", Float) = 1
        _WaveA("Wave A (dir, steepness, wavelength)", Vector) = (1,0,0.5,10)
        _WaveB("Wave B", Vector) = (0,1,0.25,20)
        _WavesStrength ("Waves Strength", Range(0,1)) = 1

        [Header(Underwater)]
        _WaterSurfaceDistortionStrength ("Water distortion strength", Float) = 1
    }
    CGINCLUDE

    #include "RGBShadersShared.cginc"
    #include "RGBLighting.cginc"

    #define SMOOTHSTEP_AA 0.01


    // Blends two colors using the same algorithm that our shader is using
        // to blend with the screen. This is usually called "normal blending",
        // and is similar to how software like Photoshop blends two layers.
    float4 alphaBlend(float4 top, float4 bottom)
    {
        float3 color = (top.rgb * top.a) + (bottom.rgb * (1 - top.a));
        float alpha = top.a + bottom.a * (1 - top.a);

        return float4(color, alpha);
    }

    struct Input
    {
        float2 uv_MainTex;
        float3 worldNormal;
        INTERNAL_DATA
        float3 worldPos;
        float4 screenPos;
        float3 viewDir;
        float3 viewNormal;
        float facing : VFACE;
        float3 nearPlanePos;
    };

    sampler2D _MainTex;
    half _Glossiness;
    half _Metallic;
    fixed4 _Color;
    float _Alpha;

    float4 _FlowTilingScale1;
    float4 _FlowSpeed1;
    float4 _FlowTilingScale2;
    float4 _FlowSpeed2;

    uniform sampler2D _CameraDepthTexture;
    sampler2D _CameraNormalsTexture;

    float _DepthThreshold;
    float4 _IntersectColor;

    float _DepthMaxDistance;
    float4 _DepthGradientShallow;
    float4 _DepthGradientDeep;

    float _FoamMaxDistance;
    float _FoamMinDistance;

    float _Reflectivity;
    float _ReflectionNormalStrength;
    uniform sampler2D _PlanarReflectionRT;

    float _CircleFalloff;
    float _CircleFalloffSmoothness;

    // Waves
    float4 _WaveA;
    float4 _WaveB;
    float _WavesStrength;

    // Submergence
    uniform float WaterLevel;
    sampler2D _SubmergeTex;

    uniform sampler2D _UnderwaterTex;
    float _WaterSurfaceDistortionStrength;

    uniform half4 _CameraDepthTexture_TexelSize;

    ENDCG
    SubShader
    {
        Tags 
        { 
            "RenderType" = "Transparent"
            "IgnoreProjector" = "True"
            "Queue" = "Transparent"
        }
        LOD 200

        GrabPass
        {
            "_UnderwaterTex"
        }

        //Blend SrcAlpha OneMinusSrcAlpha // additive blending for a simple "glow" effect
        Cull Off // render backfaces as well
        ZWrite On // don't write into the Z-buffer, this effect shouldn't block objects
        ZTest LEqual

        CGPROGRAM
        #pragma surface surf StandardSpecular fullforwardshadows vertex:vert 
        #pragma target 4.5
        #pragma shader_feature GESTNER

        //Current camera
        #define NEAR_PLANE _ProjectionParams.y
        #define ASPECT _ScreenParams.x / _ScreenParams.y
        #define CAM_FOV unity_CameraInvProjection._m11
        #define CAM_POS _WorldSpaceCameraPos
        #define CAM_RIGHT unity_WorldToCamera[0].xyz //Possibly flipped as well, but doesn't matter
        #define CAM_UP unity_WorldToCamera[1].xyz
        //The array variant is flipped when stereo rendering is in use. Using the camera center forward vector also works for VR
        #define CAM_FWD -UNITY_MATRIX_V[2].xyz

        float3 GerstnerWave(
            float4 wave, float3 p, inout float3 tangent, inout float3 binormal
        ) {
            float steepness = wave.z;
            float wavelength = wave.w;
            float k = 2 * UNITY_PI / wavelength;
            float c = sqrt(9.8 / k);
            float s = max(abs(wave.x), abs(wave.y));
            float2 d = normalize(wave.xy);
            float f = k * (dot(d, p.xz) - c * _Time.y * s);
            float a = steepness / k;

            //p.x += d.x * (a * cos(f));
            //p.y = a * sin(f);
            //p.z += d.y * (a * cos(f));

            tangent += float3(
                -d.x * d.x * (steepness * sin(f)),
                d.x * (steepness * cos(f)),
                -d.x * d.y * (steepness * sin(f))
            );
            binormal += float3(
                -d.x * d.y * (steepness * sin(f)),
                d.y * (steepness * cos(f)),
                -d.y * d.y * (steepness * sin(f))
            );
            return float3(
                d.x * (a * cos(f)),
                a * sin(f),
                d.y * (a * cos(f))
            );
        }

        void vert(inout appdata_full v, out Input o)
        {
            UNITY_INITIALIZE_OUTPUT(Input, o);
            o.viewNormal = COMPUTE_VIEW_NORMAL;

            //v.vertex.xyz = mul(unity_ObjectToWorld, v.vertex.xyz);

            // Gestner Waves
            #ifdef GESTNER
            float3 gridPoint = mul(unity_ObjectToWorld, v.vertex.xyz);
            float3 tangent = float3(1, 0, 0);
            float3 binormal = float3(0, 0, 1);
            float3 p = v.vertex.xyz;
            p += GerstnerWave(_WaveA, gridPoint, tangent, binormal);
            p += GerstnerWave(_WaveB, gridPoint, tangent, binormal);
            float3 normal = normalize(cross(binormal, tangent));

            v.normal = normal;
            v.vertex.xyz = lerp(v.vertex.xyz, p, _WavesStrength);
            #endif

            float4 vertexProgjPos = mul(UNITY_MATRIX_MV, v.vertex);
            o.nearPlanePos = v.vertex;
        }

        float3 _DeepColor, _ShallowColor;
        float _FogScale, _SSSOpacity, _FogDensity;

        float3 ColorThroughWater(float3 color, float3 volumeColor, float distThroughWater, float depth)
        {
            distThroughWater = max(0, distThroughWater);
            return lerp(color, volumeColor, 1 - saturate(exp(-_FogDensity * distThroughWater)));
        }


        float ShlickFresnel(float3 viewDir, float3 normal)
        {
            const float R = 0.02;
            return R + (1 - R) * Pow5(1 - saturate(abs(dot(viewDir, normal))));
        }

        float isUnderwater = 0;
        float _DistanceRange;
        float4 _CloseColor;
        float4 _FarColor;

        float _Perturbation;
        float _SunIntensity;

        void surf (Input i, inout SurfaceOutputStandardSpecular o)
        {
            /////////////////////////////////////////////
            // Standard + Alpha
            o.Specular = _SpecularColor * _Alpha;
            o.Smoothness = _Glossiness;
            o.Alpha = _Alpha;

            /////////////////////////////////////////
            // Normal Calculations
            fixed2 flowUV1;
            flowUV1.x = (i.worldPos.x + _Time.x * _FlowSpeed1.x) * 
                _FlowTilingScale1.zw / _FlowTilingScale1.xy;
            flowUV1.y = (i.worldPos.z + _Time.x * _FlowSpeed1.y) * 
                _FlowTilingScale1.zw / _FlowTilingScale1.xy;

            fixed2 flowUV2;
            flowUV2.x = (i.worldPos.x + _Time.x * _FlowSpeed2.x) * 
                _FlowTilingScale2.zw / _FlowTilingScale2.xy;
            flowUV2.y = (i.worldPos.z + _Time.x * _FlowSpeed2.y) * 
                _FlowTilingScale2.zw / _FlowTilingScale2.xy;

            fixed3 N1 = UnpackScaleNormal(tex2D(_BumpTex, flowUV1 ), _BumpStrength);
            fixed3 N2 = UnpackScaleNormal(tex2D(_BumpTex, flowUV2 ), _BumpStrength);

            fixed3 N = lerp(N1, N2, 0.5);

            //o.Normal = N;

            ////////////////////////////////////////////////////////////
            // Depth rendering and Foam
            // Retrieve the current depth value of the surface behind the
            // pixel we are currently rendering.
            // raw depth
            float existingDepth01 = tex2Dproj(_CameraDepthTexture, UNITY_PROJ_COORD(i.screenPos)).r;
            // Convert the depth from non-linear 0...1 range to linear
            // depth, in Unity units.
            float existingDepthLinear = LinearEyeDepth(existingDepth01);

            // Difference, in Unity units, between the water's surface and the object behind it.
            float depthDifference = existingDepthLinear - i.screenPos.w;

            // Calculate the color of the water based on the depth using our two gradient colors.
            float waterDepthDifference01 = saturate(depthDifference / _DepthMaxDistance);
            float4 waterColor = lerp(_DepthGradientShallow, _DepthGradientDeep, waterDepthDifference01);

            // Retrieve the view-space normal of the surface behind the
            // pixel we are currently rendering.
            float3 existingNormal = tex2Dproj(_CameraNormalsTexture, UNITY_PROJ_COORD(i.screenPos));

            float3 normalDot = saturate(dot(existingNormal, i.viewNormal));
            float foamDistance = lerp(_FoamMaxDistance, _FoamMinDistance, normalDot);
            float foamDepthDifference01 = saturate(depthDifference / foamDistance);

            float foamDiff = foamDepthDifference01; // *(1.0 - ripples.b);
            float4 waterTopColor = (1 - foamDiff) * _IntersectColor;

            // Underwater texture
            float2 underwaterUV = i.screenPos.xy / i.screenPos.w;
            #if UNITY_UV_STARTS_AT_TOP
            if (_CameraDepthTexture_TexelSize.y < 0) {

                underwaterUV.y = 1 - underwaterUV.y;
            }
            #endif
            float3 underwaterBackgroundColor = tex2D(_UnderwaterTex, saturate(underwaterUV + N.xy * 2 * _WaterSurfaceDistortionStrength)).rgb;

            o.Albedo = underwaterBackgroundColor * _Color;
                //alphaBlend(waterTopColor, _Color);
                //ColorThroughWater(alphaBlend(waterTopColor, waterColor), underwaterBackgroundColor, depthDifference, existingDepthLinear);

            ///////////////////////////////////////////////////////////
            // Underwater surface
            float3 viewDir = _WorldSpaceCameraPos - i.worldPos;
            float viewDist = length(viewDir);
            viewDir = viewDir / viewDist;

            float submergence = tex2D(_SubmergeTex, i.screenPos.xy / i.screenPos.w);

            bool backface = dot(i.worldNormal, viewDir) < 0;
            bool underwater = i.facing < 0 || submergence < 0.5;

            o.Normal = reflect(o.Normal, i.viewDir);

            // Fresnel light
            float fresnel = ShlickFresnel(i.viewDir, o.Normal);
            o.Albedo += fresnel * _LightColor0.xyz * _SunIntensity;
        }

        ENDCG
    }
    FallBack "Transparent/VertexLit"
}
